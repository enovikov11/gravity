<!DOCTYPE html>
<html>

<head>
    <meta name="copyright" content="© 2025 Evgenii Novikov & co-authors">
    <style>
        body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100vh;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
    </style>
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,maximum-scale=1">
    <meta charset="utf-8" />
</head>

<body>
    <div class="nospawn">
        v8 <a href="versions.html">Версии и changelog</a> <span class="stats"></span><br />
        <button onclick="clearAll()">clear</button>
        <button onclick="playpause(this)">pause</button>
    </div>
    <script>
        /*
            Идеи и фичреквесты:
            - Не притягивать к центру если 1шт, притягивать трейсеры тоже
            - Галочка центрировать или нет
            - Сеточка фона, чтобы было понятно относительное движение
            - Генератор рандомных гифок, канал в тг
            - Упругие столкновения, столкновения со взрывом
            - Порефакторить
            - Copy url кнопка
            - Добавить стилей для кнопок и интерфейса
            - Обучение
            - Скейлинг карты по кнопке
            - Стрелочки с векторами скорости и ускорения для отображения
            - Возможность перемещать или менять объекты в паузе
            - Чтить закон сохранения энергии
            - Онлайн
            - Метод интегрирования второго (или даже четверного) порядка

            Советы от Kright:
            - Если ты силу будешь убавлять пропорционально радиусу, а не квадрату радиуса, то у тебя вместо стабильных эллиптических орбит будет фигня
            - А ещё я советую юзать метод интегрирования второго порядка (в идеале вообще четвёртого взять), тогда точность намного лучше будет.
            Вот прям метод интегрирования четвёртого порядка за один шаг может уделать по точности сотню шагов первого порядка точности
            - https://kright.github.io/2025/03/12/Численненное-интегрирование-для-игровой-физики.html
            - Можешь для начала метод Верле попробовать
            - Там вместо скоростей хранятся предыдущая координата и текущая
            - Ещё кстати если в коде поменяешь обновления координаты и скорости местами, то получится полу-неявный метод Эйлера, он симплектический
            - Скорости в явном виде в Верле вообще нет
        */

        // EPS нужен чтобы ограничивать силу близких взаимодействий
        // Формула гравитации не настоящая, делит на r, не на r^2 тк так красивее (exp)

        const params = new URLSearchParams(location.search);
        let G = +(params.get("G") ?? 0.01);
        let EPS = +(params.get("EPS") ?? 10);
        let pwr = +(params.get("exp") ?? 1);
        let walls = (params.get("walls") ?? "NONE");
        let stepsPerFrame = +(params.get("spf") ?? 100);
        let doRecenter = (params.get("recenter") ?? "1") == "1";
        let doTracers = (params.get("tracers") ?? "1") == "1";

        if (!["NONE", "DUMP", "BOUNCE"].includes(walls)) {
            walls = "NONE";
        }

        let points = [], lastTime = Date.now(), point = null, halt = false;
        let statsElem = document.querySelector(".stats"), frames = 0, steps = 0, visibleCount = 0, statText = "";

        const numbers = location.hash.slice(1).split(",").map(e => +e);

        if (numbers.length % 5 == 0 && !numbers.some(e => Number.isNaN(e))) {
            for (let i = 0; i < numbers.length; i += 5) {
                points.push(addPoint(numbers[i], numbers[i + 1], numbers[i + 2], numbers[i + 3], numbers[i + 4]));
            }
        }

        function playpause(button) {
            halt = !halt;
            button.innerText = halt ? "play" : "pause";
        }

        function clearAll() {
            for (let point of points) {
                document.body.removeChild(point);

                if (point.tracers) {
                    for (let tracer of point.tracers) {
                        document.body.removeChild(tracer);
                    }
                }
            }

            points = [];
        }

        function updateSize() {
            this.r = Math.sqrt(this.m) * 5;
            this.style.width = this.r * 2 + "px";
            this.style.height = this.r * 2 + "px";
            this.style.borderRadius = this.r + "px";
        }

        function updatePos() {
            this.style.left = this.px - this.r + "px";
            this.style.top = this.py - this.r + "px";

            if (!doTracers || this.tracers.length == 0) { return; }

            this.tracerSkip = (this.tracerSkip + 1) % 5;

            if (this.tracerSkip != 0) { return; }

            this.tracers[this.tracersActive].style.left = this.px - 3 + "px";
            this.tracers[this.tracersActive].style.top = this.py - 3 + "px";

            this.tracersActive = (this.tracersActive + 1) % this.tracers.length;
        }

        document.querySelector(".nospawn").addEventListener("pointerdown", e => e.stopPropagation());
        document.querySelector(".nospawn").addEventListener("pointermove", e => e.stopPropagation());
        document.querySelector(".nospawn").addEventListener("pointerup", e => e.stopPropagation());

        function addPoint(m, px, py, vx, vy) {
            let point = document.createElement("div");

            point.style.backgroundColor = `hsl(${(251 * points.length % 360) | 0}deg 100% 50%)`;
            point.style.position = "absolute";

            point.m = m;
            point.addedAt = Date.now();

            point.px = px;
            point.py = py;
            point.vx = vx;
            point.vy = vy;

            point.updateSize = updateSize;
            point.updatePos = updatePos;

            if (doTracers) {
                point.tracers = [];
                point.tracersActive = 0;
                point.tracerSkip = 0;
            }

            point.updateSize();
            point.updatePos();

            if (doTracers) {
                for (let i = 0; i < 10; i++) {
                    let tracer = document.createElement("div");

                    tracer.style.backgroundColor = point.style.backgroundColor;
                    tracer.style.position = "absolute";

                    tracer.style.left = point.style.left;
                    tracer.style.top = point.style.top;

                    tracer.style.width = tracer.style.height = "6px";
                    tracer.style.borderRadius = "3px";

                    document.body.appendChild(tracer);
                    point.tracers.push(tracer);
                }
            }

            document.body.appendChild(point);
            return point;
        }

        addEventListener("pointerdown", e => {
            point = addPoint(0.1, e.pageX, e.pageY, 0, 0);
        });

        const vCoeff = -0.003;

        addEventListener("pointermove", e => {
            if (!point) { return; }

            if ((e.pageX - point.px) ** 2 + (e.pageY - point.py) ** 2 > 100) { point.lockSize = true; }

            if (doTracers) {
                for (let i = 0; i < point.tracers.length; i++) {
                    point.tracers[i].style.left = e.pageX + ((i + 1) / point.tracers.length) * (point.px - e.pageX) - 3 + "px";
                    point.tracers[i].style.top = e.pageY + ((i + 1) / point.tracers.length) * (point.py - e.pageY) - 3 + "px";
                }
            }
        });

        addEventListener("pointerup", e => {
            point.vx = vCoeff * (e.pageX - point.px);
            point.vy = vCoeff * (e.pageY - point.py);

            if (doTracers) {
                for (let tracer of point.tracers) {
                    tracer.style.left = point.px - 3 + "px";
                    tracer.style.top = point.py - 3 + "px";
                }
            }

            points.push(point);
            point = null;
        });

        function serialize() {
            let numbers = [];

            for (let point of points) {
                numbers.push(point.m, point.px, point.py, point.vx, point.vy);
            }

            return numbers.map(e => e.toFixed(2)).join(",");
        }

        setInterval(() => {
            statText = `FPS: ${frames}, simulations per second: ${steps}, planets: ${points.length}`;
            frames = 0;
            steps = 0;

            location.hash = serialize();
        }, 1000);

        function simulateStep(dt) {
            steps++;

            for (let item of points) {
                item.ax = 0;
                item.ay = 0;
            }

            for (let i = 0; i < points.length; ++i) {
                const a = points[i];

                for (let j = i + 1; j < points.length; ++j) {
                    const b = points[j];

                    const dx = a.px - b.px, dy = a.py - b.py;
                    const r = Math.sqrt(dx ** 2 + dy ** 2 + EPS);
                    const F = G * a.m * b.m / (r ** pwr);

                    a.ax -= (F / a.m) * (dx / r);
                    a.ay -= (F / a.m) * (dy / r);

                    b.ax += (F / b.m) * (dx / r);
                    b.ay += (F / b.m) * (dy / r);
                }
            }

            for (let item of points) {
                item.vx += item.ax * dt;
                item.vy += item.ay * dt;

                item.px += item.vx * dt;
                item.py += item.vy * dt;
            }
        }

        function applyWalls() {
            if (walls === "NONE") { return; }

            const c = walls == "DUMP" ? 0 : -1;

            for (let point of points) {
                if (point.px < 0) {
                    point.px *= -1;
                    point.vx *= c;
                }

                if (point.px > window.innerWidth) {
                    point.px = 2 * window.innerWidth - point.px;
                    point.vx *= c;
                }

                if (point.py < 0) {
                    point.py *= -1;
                    point.vy *= c;
                }

                if (point.py > window.innerHeight) {
                    point.py = 2 * window.innerHeight - point.py;
                    point.vy *= c;
                }
            }
        }

        function recenter() {
            let totalM = 0, totalX = 0, totalY = 0;

            for (let point of points) {
                totalM += point.m;
                totalX += point.m * point.px;
                totalY += point.m * point.py;
            }

            let dx = window.innerWidth / 2 - totalX / totalM, dy = window.innerHeight / 2 - totalY / totalM;

            for (let point of points) {
                point.px += dx / 30;
                point.py += dy / 30;
            }
        }

        function render() {
            if (halt) {
                requestAnimationFrame(render);
                return;
            }

            frames++;

            const now = Date.now(), dt = now - lastTime;
            lastTime = now;

            if (dt > 1000) {
                console.warn("Clock skew detected");
            } else {
                for (let i = 0; i < stepsPerFrame; i++) { simulateStep(dt / stepsPerFrame); }

                visibleCount = 0;

                applyWalls();

                if (doRecenter) {
                    recenter();
                }

                for (let point of points) {
                    point.updatePos();

                    let xPct = point.px / window.innerWidth, yPct = point.py / window.innerHeight;

                    if (0 < xPct && xPct < 1 && 0 < yPct && yPct < 1) { visibleCount++; }
                }

                statsElem.innerText = statText + `, visible: ${visibleCount}`;
            }

            if (point && !point.lockSize) {
                point.m = 0.1 + Math.sqrt(Date.now() - point.addedAt) / 4;
                point.updateSize();
                point.updatePos();
            }

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>

</html>