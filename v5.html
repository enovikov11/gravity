<!DOCTYPE html>
<html>

<head>
    <meta name="copyright" content="© 2025 Evgenii Novikov & co-authors">
    <style>
        body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100vh;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
    </style>
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,maximum-scale=1">
    <meta charset="utf-8" />
</head>

<body>
    <div class="nospawn">v5 <a href="versions.html">Версии и changelog</a> <span class="stats"></span></div>
    <script>
        /*
            Идеи и фичреквесты:
            - Play/pause import/export (based on url)
            - Sim speed
            - Try real formula
            - Возможность задавать не только точки, но и их импульсы, как в Angry Birds
            - Трейсеры с путями
            - Стрелочки с векторами скорости и ускорения
            - Выбор формулы
            - Скейлинг карты
            - Перемещение и изменение скорости
            - Reverse time
            - Адаптивное количество симуляций в секунду

            v6:
        */

        let points = [], lastTime = Date.now(), stepsPerFrame = 100, point = null;
        let statsElem = document.querySelector(".stats"), frames = 0, steps = 0, visibleCount = 0;

        function updateSize() {
            this.r = Math.sqrt(this.m) * 5;
            this.style.width = this.r * 2 + "px";
            this.style.height = this.r * 2 + "px";
            this.style.borderRadius = this.r + "px";
        }

        function updatePos() {
            this.style.left = this.px - this.r + "px";
            this.style.top = this.py - this.r + "px";
        }

        function add(e) {
            point = document.createElement("div");

            point.style.backgroundColor = `hsl(${(251 * points.length % 360) | 0}deg 100% 50%)`;
            point.style.position = "absolute";

            point.m = 0.1;
            point.addedAt = Date.now();

            point.px = e.pageX;
            point.py = e.pageY;

            point.vx = 0;
            point.vy = 0;

            point.updateSize = updateSize;
            point.updatePos = updatePos;

            point.updateSize();
            point.updatePos();

            document.body.appendChild(point);
        }

        document.querySelector(".nospawn").addEventListener("pointerdown", e => e.stopPropagation());
        document.querySelector(".nospawn").addEventListener("pointerup", e => e.stopPropagation());

        addEventListener("pointerdown", add);
        addEventListener("pointerup", () => { points.push(point); point = null; });

        setInterval(() => {
            statsElem.innerText = `FPS: ${frames}, simulations per second: ${steps}, planets: ${points.length}, visible: ${visibleCount}`;
            frames = 0;
            steps = 0;
        }, 1000);

        // EPS нужен чтобы ограничивать силу близких взаимодействий
        const G = 0.01, EPS = 10;

        function simulateStep(dt) {
            steps++;

            for (let item of points) {
                item.ax = 0;
                item.ay = 0;
            }

            for (let i = 0; i < points.length; ++i) {
                const a = points[i];

                for (let j = i + 1; j < points.length; ++j) {
                    const b = points[j];

                    const dx = a.px - b.px, dy = a.py - b.py;
                    const r = Math.sqrt(dx ** 2 + dy ** 2 + EPS);

                    // Формула гравитации не настоящая, делит на r, не на r^2 тк так красивее
                    const F = G * a.m * b.m / r;

                    a.ax -= (F / a.m) * (dx / r);
                    a.ay -= (F / a.m) * (dy / r);

                    b.ax += (F / b.m) * (dx / r);
                    b.ay += (F / b.m) * (dy / r);
                }
            }

            for (let item of points) {
                item.vx += item.ax * dt;
                item.vy += item.ay * dt;

                item.px += item.vx * dt;
                item.py += item.vy * dt;
            }
        }

        function render() {
            frames++;

            const now = Date.now(), dt = now - lastTime;
            lastTime = now;

            if (dt > 1000) {
                console.warn("Clock skew detected");
            } else {
                for (let i = 0; i < stepsPerFrame; i++) { simulateStep(dt / stepsPerFrame); }

                visibleCount = 0;

                for (let point of points) {
                    point.updatePos();

                    let xPct = point.px / window.innerWidth, yPct = point.px / window.innerHeight;

                    if (0 < xPct && xPct < 1 && 0 < yPct && yPct < 1) { visibleCount++; }
                }
            }

            if (point) {
                point.m = 0.1 + Math.sqrt(Date.now() - point.addedAt) / 4;
                point.updateSize();
                point.updatePos();
            }

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>

</html>